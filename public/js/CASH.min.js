/* CASH Asynchronous State Handling */

function CASH() {

    'use strict';

    //install ourselves in the global scope for convenience
    window._CASH = this;
    this.VERSION = '0.1';

}

CASH.prototype.bindContext = function ( fn, context, args ) {

    'use strict';

    var applyArgs = [];

    if ( args instanceof Array ) {
        applyArgs = args;
    } else {
        applyArgs.push( args );
    }

    return function () { fn.apply( context, applyArgs ); };

};

CASH.prototype.each = function ( list, fn, scope ) {
    'use strict';

    var i = 0, l = list.length;

    if ( Array.prototype.forEach ) {
        list.forEach( fn, scope );
    } else {
        for ( i = 0; i < l; i++ ) {
            fn.call( scope, list[i], i, this );
        }
    }

};

CASHAjax = function ( method, resource, headers, data, actions, progressCallback, timeout ) {

    'use strict';

    var that = this,
        xhr = new XMLHttpRequest(),
        updateProgress,
        resetProgress,
        startProgress,
        onTimeout,
        networkTimeout,
        timeoutDelay = timeout || 5000,
        i;

    //make sure the core object has been instantiated
    if ( !window._CASH ) {
        window._CASH = new CASH();
    }

    if ( Object.prototype.hasOwnProperty.call( xhr, 'upload' ) ) {

        if ( method == 'GET' ) {

            updateProgress = function ( e ) {
                if ( e.lengthComputable ) {
                    progressCallback( Math.round( ( e.loaded / e.total ) * 100 ) );
                }
            };

            resetProgress = function ( e ) {
                progressCallback( -1 );
            };

            xhr.addEventListener( 'progress', updateProgress, false );
            xhr.addEventListener( 'load', resetProgress, false );
            xhr.addEventListener( 'error', resetProgress, false );
            xhr.addEventListener( 'abort', resetProgress, false );

        } else if ( method == 'POST' ) {

            startProgress = function ( e ) {
                progressCallback( 0 );
            };

            updateProgress = function ( e ) {
                if ( e.lengthComputable ) {
                    progressCallback( Math.round( ( e.loaded / e.total ) * 100 ) );
                }
            };

            resetProgress = function ( e ) {
                progressCallback( -1 );
            };

            xhr.upload.addEventListener( 'loadstart', startProgress, false );
            xhr.upload.addEventListener( 'progress', updateProgress, false );
            xhr.upload.addEventListener( 'load', resetProgress, false );
            xhr.upload.addEventListener( 'error', resetProgress, false );
            xhr.upload.addEventListener( 'abort', resetProgress, false );

        }

    }

    function readyStateChangeHandler ( e ) {

        var statusCode;

        if ( this.readyState === 4 ) {

            //ie8 will sputter and die if you try to check the xhr object's
            //.status property and it hasn't reached readyState 4 yet, so
            //do this inside the readyState check
            if ( typeof e === 'undefined' ) {
                statusCode = xhr.status;
		if ( statusCode === 1223 ) {
		    statusCode = 204;
		}
            } else {
                statusCode = e.target.status;
            }

            //clear the network timeout counter
            clearTimeout( networkTimeout );

            if ( actions.hasOwnProperty( statusCode ) && typeof actions[statusCode] === 'function' ) {
                //if an action has been defined for this status code, execute that callback
                actions[statusCode]( this.responseText );
            } else {
                //...otherwise, fall back to the default
                actions['otherwise']( this.responseText );
            }

        }

    };

    //check if we have to do things the 'old fashioned' way using onreadystatechange
    if ( typeof xhr.onload === 'undefined' ) {
        xhr.onreadystatechange = readyStateChangeHandler;
    //otherwise use the onload event
    } else {
        xhr.onload = readyStateChangeHandler;
    }

    xhr.open( method, resource );

    if ( typeof headers !== 'undefined' && typeof headers.length !== 'undefind' && headers.length > 0 ) {
        i = headers.length;
        while ( i-- ) {
            xhr.setRequestHeader( headers[i].type, headers[i].parameter );
        }
    }

    //abort the request after 5 seconds and show the 'could not connect' message
    //note that the abort() method works here because we have instantiated the xhr object within this anonymous function's scope
    //...otherwise we'd have to store references to all the xhr objects that are active and then cancel each by getting a reference to the
    //specific object we're looking to cancel (ugh)
    onTimeout = function () {
        xhr.abort();
        actions['otherwise']( false );
    };

    networkTimeout = setTimeout( onTimeout, timeoutDelay );

    if ( typeof data !== 'undefined' && data !== false ) {
        xhr.send( data );
    } else {
        xhr.send( null );
    }

};

CASHComputation = function ( scope, data, map, reduce, callback, interval ) {

    'use strict';

    //make sure the core object has been instantiated
    if ( !window._CASH ) {
        window._CASH = new CASH();
    }

    if ( typeof scope !== 'object' ) {
        throw new TypeError( 'CASHComputation - Argument 1 must be an object.' );
    }

    if ( !( data instanceof Array ) ) {
        throw new TypeError( 'CASHComputation - Argument 2 must be an array.' );
    }

    if ( typeof map !== 'function' ) {
        throw new TypeError( 'CASHComputation - Argument 3 must be a function.' );
    }

    if ( typeof reduce !== 'function' ) {
        throw new TypeError( 'CASHComputation - Argument 4 must be a function.' );
    }

    if ( typeof callback !== 'function' ) {
        throw new TypeError( 'CASHComputation - Argument 5 must be a function.' );
    }

    if ( interval && typeof interval !== 'number' ) {
        throw new TypeError( 'CASHComputation - Argument 6 must be a number.' );
    }

    this.scope = scope;
    this.data = data;
    this.mapFn = map;
    this.reduceFn = reduce;
    this.callback = callback;
    this.interval = parseInt( interval, 10 ) || 100;

    this.temp = [];
    this.result = '';

};

CASHComputation.prototype.execute = function () {

    'use strict';

    var that = this,
        queue = new CASHQueue();

    //map operations
    queue.addItem( function ( nextItem ) { that.applyMap( 0, nextItem ); } );
    
    //reduce operations
    queue.addItem( function ( nextItem ) { that.applyReduce( that.temp, nextItem ); } );
    
    //execute computation callback
    queue.addItem( function () { that.callback( that.result ); } );
    
    queue.execute();

};

CASHComputation.prototype.applyMap = function ( count, callback ) {

    'use strict';

    var that = this,
        length = this.data.length,
        start = Date.now(),
        interval = this.interval;

    if ( count === length ) {
        return callback();
    }

    while ( ( Date.now() - start ) < interval ) {
        if ( count === length ) {
            return callback();
        }
        this.temp.push( this.mapFn.call( this.scope, this.data[count], count, this.scope ) );
        count = count + 1;
    }

    setTimeout( function () { that.applyMap( count, callback ); }, 0 );

};

CASHComputation.prototype.applyReduce = function ( data, callback ) {

    'use strict';

    this.result = this.reduceFn.call( this.scope, data, this.scope );

    return callback();

};

CASHQueue = function () {

    'use strict';

    //make sure the core object has been instantiated
    if ( !window._CASH ) {
        window._CASH = new CASH();
    }

    this.items = [];
    this.current = -1;

};

CASHQueue.prototype.addItem = function ( fn ) {

    'use strict';

    var that = this;

    this.items.push( function () { fn.call( that, function () { that.execute(); } ); } );

};

CASHQueue.prototype.execute = function () {

    'use strict';

    this.current = this.current + 1;

    if ( this.current < this.items.length && this.items.length > 0 ) {

        //immediately execute the next indexed function
        this.items[this.current]();

    }

};

CASHQueue.prototype.reset = function () {

    'use strict';

    this.current = -1;

};

CASHQueue.prototype.clear = function () {

    'use strict';

    this.items = [];
    this.current = -1;

};
